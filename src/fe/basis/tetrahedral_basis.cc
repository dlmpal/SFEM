#include "basis.h"
#include "quadrature.h"

namespace sfem::fe::basis
{
    //=============================================================================
    int LinearTetrahedralBasis::dim() const
    {
        return 3;
    }
    //=============================================================================
    int LinearTetrahedralBasis::n_nodes() const
    {
        return 4;
    }
    //=============================================================================
    int LinearTetrahedralBasis::n_qpts() const
    {
        return 4;
    }
    //=============================================================================
    Scalar LinearTetrahedralBasis::qwt(int npt) const
    {
        return tetrahedral_qwt_4[npt];
    }
    //=============================================================================
    void LinearTetrahedralBasis::qpt(int npt, Scalar pt[]) const
    {
        pt[0] = tetrahedral_qpt_4[npt * 3 + 0];
        pt[1] = tetrahedral_qpt_4[npt * 3 + 1];
        pt[2] = tetrahedral_qpt_4[npt * 3 + 2];
    }
    //=============================================================================
    void LinearTetrahedralBasis::eval_shape(const Scalar pt[], Scalar N[]) const
    {
        N[0] = 1 - pt[0] - pt[1] - pt[2];
        N[1] = pt[0];
        N[2] = pt[1];
        N[3] = pt[2];
    }
    //=============================================================================
    void LinearTetrahedralBasis::eval_shape_grad(const Scalar pt[], Scalar dNdxi[]) const
    {
        dNdxi[0 * 3 + 0] = -1.0;
        dNdxi[0 * 3 + 1] = -1.0;
        dNdxi[0 * 3 + 2] = -1.0;

        dNdxi[1 * 3 + 0] = 1.0;
        dNdxi[1 * 3 + 1] = 0.0;
        dNdxi[1 * 3 + 2] = 0.0;

        dNdxi[2 * 3 + 0] = 0.0;
        dNdxi[2 * 3 + 1] = 1.0;
        dNdxi[2 * 3 + 2] = 0.0;

        dNdxi[3 * 3 + 0] = 0.0;
        dNdxi[3 * 3 + 1] = 0.0;
        dNdxi[3 * 3 + 2] = 1.0;
    }
    //=============================================================================
    int QuadraticTehtrahedralBasis::dim() const
    {
        return 3;
    }
    //=============================================================================
    int QuadraticTehtrahedralBasis::n_nodes() const
    {
        return 10;
    }
    //=============================================================================
    int QuadraticTehtrahedralBasis::n_qpts() const
    {
        return 14;
    }
    //=============================================================================
    Scalar QuadraticTehtrahedralBasis::qwt(int npt) const
    {
        return tetrahedral_qwt_14[npt];
    }
    //=============================================================================
    void QuadraticTehtrahedralBasis::qpt(int npt, Scalar pt[]) const
    {
        pt[0] = tetrahedral_qpt_14[npt * 3 + 0];
        pt[1] = tetrahedral_qpt_14[npt * 3 + 1];
        pt[2] = tetrahedral_qpt_14[npt * 3 + 2];
    }
    //=============================================================================
    void QuadraticTehtrahedralBasis::eval_shape(const Scalar pt[], Scalar N[]) const
    {
        Scalar L1 = 1 - pt[0] - pt[1] - pt[2];
        Scalar L2 = pt[0];
        Scalar L3 = pt[1];
        Scalar L4 = pt[2];

        // Corner nodes
        N[0] = L1 * (2 * L1 - 1);
        N[1] = L2 * (2 * L2 - 1);
        N[2] = L3 * (2 * L3 - 1);
        N[3] = L4 * (2 * L4 - 1);

        // Mid-side nodes
        N[4] = 4 * L2 * L1;
        N[5] = 4 * L2 * L3;
        N[6] = 4 * L3 * L1;
        N[7] = 4 * L4 * L1;
        N[8] = 4 * L3 * L4;
        N[9] = 4 * L2 * L4;
    }
    //=============================================================================
    void QuadraticTehtrahedralBasis::eval_shape_grad(const Scalar pt[], Scalar dNdxi[]) const
    {
        // Corner nodes
        dNdxi[0 * 3 + 0] = 4 * pt[0] + 4 * pt[1] + 4 * pt[2] - 3;
        dNdxi[0 * 3 + 1] = 4 * pt[0] + 4 * pt[1] + 4 * pt[2] - 3;
        dNdxi[0 * 3 + 2] = 4 * pt[0] + 4 * pt[1] + 4 * pt[2] - 3;

        dNdxi[1 * 3 + 0] = 4 * pt[0] - 1;
        dNdxi[1 * 3 + 1] = 0;
        dNdxi[1 * 3 + 2] = 0;

        dNdxi[2 * 3 + 0] = 0;
        dNdxi[2 * 3 + 1] = 4 * pt[1] - 1;
        dNdxi[2 * 3 + 2] = 0;

        dNdxi[3 * 3 + 0] = 0;
        dNdxi[3 * 3 + 1] = 0;
        dNdxi[3 * 3 + 2] = 4 * pt[2] - 1;

        // Mid-side nodes
        dNdxi[4 * 3 + 0] = -4 * (2 * pt[0] + pt[1] + pt[2] - 1);
        dNdxi[4 * 3 + 1] = -4 * pt[0];
        dNdxi[4 * 3 + 2] = -4 * pt[0];

        dNdxi[5 * 3 + 0] = 4 * pt[1];
        dNdxi[5 * 3 + 1] = 4 * pt[0];
        dNdxi[5 * 3 + 2] = 0.0;

        dNdxi[6 * 3 + 0] = -4 * pt[1];
        dNdxi[6 * 3 + 1] = -4 * (pt[0] + 2 * pt[1] + pt[2] - 1);
        dNdxi[6 * 3 + 2] = -4 * pt[1];

        dNdxi[7 * 3 + 0] = -4 * pt[2];
        dNdxi[7 * 3 + 1] = -4 * pt[2];
        dNdxi[7 * 3 + 2] = -4 * (pt[0] + pt[1] + 2 * pt[2] - 1);

        dNdxi[8 * 3 + 0] = 0;
        dNdxi[8 * 3 + 1] = 4 * pt[2];
        dNdxi[8 * 3 + 2] = 4 * pt[1];

        dNdxi[9 * 3 + 0] = 4 * pt[2];
        dNdxi[9 * 3 + 1] = 0;
        dNdxi[9 * 3 + 2] = 4 * pt[0];
    }
    //=============================================================================
    int CubicTetrahedralBasis::dim() const
    {
        return 3;
    }
    //=============================================================================
    int CubicTetrahedralBasis::n_nodes() const
    {
        return 20;
    }
    //=============================================================================
    int CubicTetrahedralBasis::n_qpts() const
    {
        return 15;
    }
    //=============================================================================
    Scalar CubicTetrahedralBasis::qwt(int npt) const
    {
        double qwt[] = {0.1817020685825351, 0.0361607142857143, 0.0361607142857143, 0.0361607142857143, 0.0361607142857143, 0.0698714945161738, 0.0698714945161738, 0.0698714945161738, 0.0698714945161738, 0.0656948493683187, 0.0656948493683187, 0.0656948493683187, 0.0656948493683187, 0.0656948493683187, 0.0656948493683187};
        return qwt[npt];
    }
    //=============================================================================
    void CubicTetrahedralBasis::qpt(int npt, Scalar pt[]) const
    {
        double xqpt[] = {0.2500000000000000, 0.0000000000000000, 0.3333333333333333, 0.3333333333333333, 0.3333333333333333, 0.7272727272727273, 0.0909090909090909, 0.0909090909090909, 0.0909090909090909, 0.4334498464263357, 0.0665501535736643, 0.0665501535736643, 0.0665501535736643, 0.4334498464263357, 0.4334498464263357};
        double yqpt[] = {0.2500000000000000, 0.3333333333333333, 0.3333333333333333, 0.3333333333333333, 0.0000000000000000, 0.0909090909090909, 0.0909090909090909, 0.0909090909090909, 0.7272727272727273, 0.0665501535736643, 0.4334498464263357, 0.0665501535736643, 0.4334498464263357, 0.0665501535736643, 0.4334498464263357};
        double zqpt[] = {0.2500000000000000, 0.3333333333333333, 0.3333333333333333, 0.0000000000000000, 0.3333333333333333,
                         0.0909090909090909, 0.0909090909090909, 0.7272727272727273, 0.0909090909090909, 0.0665501535736643,
                         0.0665501535736643, 0.4334498464263357, 0.4334498464263357, 0.4334498464263357, 0.0665501535736643};
        pt[0] = xqpt[npt];
        pt[1] = yqpt[npt];
        pt[2] = zqpt[npt];
    }

    //=============================================================================
    void CubicTetrahedralBasis::eval_shape(const Scalar pt[], Scalar N[]) const
    {
        N[0] = (-3 * pt[1] - 3 * pt[0] - 3 * pt[2] + 1) * (-1.5 * pt[1] - 1.5 * pt[0] - 1.5 * pt[2] + 1.0) * (-pt[1] - pt[0] - pt[2] + 1);
        N[1] = pt[0] * (1.5 * pt[0] - 0.5) * (3 * pt[0] - 2);
        N[2] = pt[1] * (1.5 * pt[1] - 0.5) * (3 * pt[1] - 2);
        N[3] = pt[2] * (1.5 * pt[2] - 0.5) * (3 * pt[2] - 2);
        N[4] = pt[0] * (-4.5 * pt[1] - 4.5 * pt[0] - 4.5 * pt[2] + 4.5) * (-3 * pt[1] - 3 * pt[0] - 3 * pt[2] + 2);
        N[5] = pt[0] * (3 * pt[0] - 1) * (-4.5 * pt[1] - 4.5 * pt[0] - 4.5 * pt[2] + 4.5);
        N[6] = pt[1] * (-4.5 * pt[1] - 4.5 * pt[0] - 4.5 * pt[2] + 4.5) * (-3 * pt[1] - 3 * pt[0] - 3 * pt[2] + 2);
        N[7] = pt[1] * (3 * pt[1] - 1) * (-4.5 * pt[1] - 4.5 * pt[0] - 4.5 * pt[2] + 4.5);
        N[8] = 4.5 * pt[1] * pt[2] * (3 * pt[1] - 1);
        N[9] = 4.5 * pt[1] * pt[2] * (3 * pt[2] - 1);
        N[10] = 4.5 * pt[0] * pt[2] * (3 * pt[2] - 1);
        N[11] = 4.5 * pt[0] * pt[2] * (3 * pt[0] - 1);
        N[12] = pt[2] * (-4.5 * pt[1] - 4.5 * pt[0] - 4.5 * pt[2] + 4.5) * (-3 * pt[1] - 3 * pt[0] - 3 * pt[2] + 2);
        N[13] = pt[2] * (3 * pt[2] - 1) * (-4.5 * pt[1] - 4.5 * pt[0] - 4.5 * pt[2] + 4.5);
        N[14] = 4.5 * pt[1] * pt[0] * (3 * pt[1] - 1);
        N[15] = 4.5 * pt[1] * pt[0] * (3 * pt[0] - 1);
        N[16] = 27 * pt[1] * pt[0] * pt[2];
        N[17] = pt[0] * pt[2] * (-27 * pt[1] - 27 * pt[0] - 27 * pt[2] + 27);
        N[18] = pt[1] * pt[2] * (-27 * pt[1] - 27 * pt[0] - 27 * pt[2] + 27);
        N[19] = pt[1] * pt[0] * (-27 * pt[1] - 27 * pt[0] - 27 * pt[2] + 27);
    }
    //=============================================================================
    void CubicTetrahedralBasis::eval_shape_grad(const Scalar pt[], Scalar dNdxi[]) const
    {
        dNdxi[0] = -13.5 * pt[1] * pt[1] - 27.0 * pt[1] * pt[0] - 27.0 * pt[1] * pt[2] + 18.0 * pt[1] - 13.5 * pt[0] * pt[0] - 27.0 * pt[0] * pt[2] + 18.0 * pt[0] - 13.5 * pt[2] * pt[2] + 18.0 * pt[2] - 5.5;
        dNdxi[1] = -13.5 * pt[1] * pt[1] - 27.0 * pt[1] * pt[0] - 27.0 * pt[1] * pt[2] + 18.0 * pt[1] - 13.5 * pt[0] * pt[0] - 27.0 * pt[0] * pt[2] + 18.0 * pt[0] - 13.5 * pt[2] * pt[2] + 18.0 * pt[2] - 5.5;
        dNdxi[2] = -13.5 * pt[1] * pt[1] - 27.0 * pt[1] * pt[0] - 27.0 * pt[1] * pt[2] + 18.0 * pt[1] - 13.5 * pt[0] * pt[0] - 27.0 * pt[0] * pt[2] + 18.0 * pt[0] - 13.5 * pt[2] * pt[2] + 18.0 * pt[2] - 5.5;

        dNdxi[3] = 13.5 * pt[0] * pt[0] - 9.0 * pt[0] + 1.0;
        dNdxi[4] = 0;
        dNdxi[5] = 0;

        dNdxi[6] = 0;
        dNdxi[7] = 13.5 * pt[1] * pt[1] - 9.0 * pt[1] + 1.0;
        dNdxi[8] = 0;

        dNdxi[9] = 0;
        dNdxi[10] = 0;
        dNdxi[11] = 13.5 * pt[2] * pt[2] - 9.0 * pt[2] + 1.0;

        dNdxi[12] = 13.5 * pt[1] * pt[1] + 54.0 * pt[1] * pt[0] + 27.0 * pt[1] * pt[2] - 22.5 * pt[1] + 40.5 * pt[0] * pt[0] + 54.0 * pt[0] * pt[2] - 45.0 * pt[0] + 13.5 * pt[2] * pt[2] - 22.5 * pt[2] + 9.0;
        dNdxi[13] = pt[0] * (27.0 * pt[1] + 27.0 * pt[0] + 27.0 * pt[2] - 22.5);
        dNdxi[14] = pt[0] * (27.0 * pt[1] + 27.0 * pt[0] + 27.0 * pt[2] - 22.5);

        dNdxi[15] = -27.0 * pt[1] * pt[0] + 4.5 * pt[1] - 40.5 * pt[0] * pt[0] - 27.0 * pt[0] * pt[2] + 36.0 * pt[0] + 4.5 * pt[2] - 4.5;
        dNdxi[16] = pt[0] * (4.5 - 13.5 * pt[0]);
        dNdxi[17] = pt[0] * (4.5 - 13.5 * pt[0]);

        dNdxi[18] = pt[1] * (27.0 * pt[1] + 27.0 * pt[0] + 27.0 * pt[2] - 22.5);
        dNdxi[19] = 40.5 * pt[1] * pt[1] + 54.0 * pt[1] * pt[0] + 54.0 * pt[1] * pt[2] - 45.0 * pt[1] + 13.5 * pt[0] * pt[0] + 27.0 * pt[0] * pt[2] - 22.5 * pt[0] + 13.5 * pt[2] * pt[2] - 22.5 * pt[2] + 9.0;
        dNdxi[20] = pt[1] * (27.0 * pt[1] + 27.0 * pt[0] + 27.0 * pt[2] - 22.5);

        dNdxi[21] = pt[1] * (4.5 - 13.5 * pt[1]);
        dNdxi[22] = -40.5 * pt[1] * pt[1] - 27.0 * pt[1] * pt[0] - 27.0 * pt[1] * pt[2] + 36.0 * pt[1] + 4.5 * pt[0] + 4.5 * pt[2] - 4.5;
        dNdxi[23] = pt[1] * (4.5 - 13.5 * pt[1]);

        dNdxi[24] = 0;
        dNdxi[25] = pt[2] * (27.0 * pt[1] - 4.5);
        dNdxi[26] = pt[1] * (13.5 * pt[1] - 4.5);

        dNdxi[27] = 0;
        dNdxi[28] = pt[2] * (13.5 * pt[2] - 4.5);
        dNdxi[29] = pt[1] * (27.0 * pt[2] - 4.5);

        dNdxi[30] = pt[2] * (13.5 * pt[2] - 4.5);
        dNdxi[31] = 0;
        dNdxi[32] = pt[0] * (27.0 * pt[2] - 4.5);

        dNdxi[33] = pt[2] * (27.0 * pt[0] - 4.5);
        dNdxi[34] = 0;
        dNdxi[35] = pt[0] * (13.5 * pt[0] - 4.5);

        dNdxi[36] = pt[2] * (27.0 * pt[1] + 27.0 * pt[0] + 27.0 * pt[2] - 22.5);
        dNdxi[37] = pt[2] * (27.0 * pt[1] + 27.0 * pt[0] + 27.0 * pt[2] - 22.5);
        dNdxi[38] = 13.5 * pt[1] * pt[1] + 27.0 * pt[1] * pt[0] + 54.0 * pt[1] * pt[2] - 22.5 * pt[1] + 13.5 * pt[0] * pt[0] + 54.0 * pt[0] * pt[2] - 22.5 * pt[0] + 40.5 * pt[2] * pt[2] - 45.0 * pt[2] + 9.0;

        dNdxi[39] = pt[2] * (4.5 - 13.5 * pt[2]);
        dNdxi[40] = pt[2] * (4.5 - 13.5 * pt[2]);
        dNdxi[41] = -27.0 * pt[1] * pt[2] + 4.5 * pt[1] - 27.0 * pt[0] * pt[2] + 4.5 * pt[0] - 40.5 * pt[2] * pt[2] + 36.0 * pt[2] - 4.5;

        dNdxi[42] = pt[1] * (13.5 * pt[1] - 4.5);
        dNdxi[43] = pt[0] * (27.0 * pt[1] - 4.5);
        dNdxi[44] = 0;

        dNdxi[45] = pt[1] * (27.0 * pt[0] - 4.5);
        dNdxi[46] = pt[0] * (13.5 * pt[0] - 4.5);
        dNdxi[47] = 0;

        dNdxi[48] = 27 * pt[1] * pt[2];
        dNdxi[49] = 27 * pt[0] * pt[2];
        dNdxi[50] = 27 * pt[1] * pt[0];

        dNdxi[51] = 27 * pt[2] * (-pt[1] - 2 * pt[0] - pt[2] + 1);
        dNdxi[52] = -27 * pt[0] * pt[2];
        dNdxi[53] = 27 * pt[0] * (-pt[1] - pt[0] - 2 * pt[2] + 1);

        dNdxi[54] = -27 * pt[1] * pt[2];
        dNdxi[55] = 27 * pt[2] * (-2 * pt[1] - pt[0] - pt[2] + 1);
        dNdxi[56] = 27 * pt[1] * (-pt[1] - pt[0] - 2 * pt[2] + 1);

        dNdxi[57] = 27 * pt[1] * (-pt[1] - 2 * pt[0] - pt[2] + 1);
        dNdxi[58] = 27 * pt[0] * (-2 * pt[1] - pt[0] - pt[2] + 1);
        dNdxi[59] = -27 * pt[1] * pt[0];
    }
}